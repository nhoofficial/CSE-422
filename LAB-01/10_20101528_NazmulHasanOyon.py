# -*- coding: utf-8 -*-
"""10_20101528_NazmulHasanOyon

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cXHvoM7lnfpAWkRThNm0JD0XmkV5-srC

# **Python Basics**

1. Input, Output					
2. Type Conversion, Operators					
3. Branching, Loop, Function					
4. String, List, Set, Tuple, Dictionary					
5. File I/O

### **Input, Output**
"""



"""### **Type Conversion, Operators**"""



"""### **Branching, Loop, Function**"""



"""### **String, List, Set, Tuple, Dictionary**

###  **File I/O**
"""

from google.colab import drive
drive.mount("/content/drive")

# Commented out IPython magic to ensure Python compatibility.
# %cd '/content/drive/MyDrive/BracU WorkSpace/Summer 22/CSE422/# CSE422 Lab [Student]/# Lab-01 Class Files [MKL]'

!ls

inputFile = open("/content/drive/MyDrive/Lab-01/input.txt", "r")
inputFile

print(inputFile.read())

inputFile.seek(0)
inputFile.read()

inputFile.seek(0)

test = inputFile.readlines()
test

mat = []

for e in test:
  if e[-1] == '\n':
    s = e[:-1].split()
  else:
    s = e.split()
  mat.append(s)

#print(m)

for i in range(len(mat)):
  for j in range(len(mat[i])):
    if mat[i][j] == "Y":
      mat[i][j] = 1
    else:
      mat[i][j] = 0
#print(m)      
s=[]
moves = [(0, -1), (-1, 1), (-1, -1), (1, 1), (1, -1),(-1, 0), (1, 0), (0, 1)]
        #left #left_dia #for_back #right_downdia #left_downdia #left_updia #rightup #right
def DFS(visited,moves,row, column, z):
    global s,m# here s as stack and m is the given matrix in the question.
    s.append((row, column))#pushing into the stack
    while len(s)>=1:#we will itearte the loop until stack is not empty.
        row,column=s[-1][0],s[-1][1]#inititializing the last tuple (x,y) as row and column
        for i in range(len(moves)):
            x,y = row + moves[i][0],column + moves[i][1]
            # here x denotes the new row and y denote the new column
            if x >= 0 and x <= len(mat) - 1 and y >= 0 and y <= len(mat[0]) - 1:#for the margin part
                if mat[x][y] == 1:
                    for w in visited:#for all the adjacent
                        if (x,y)!=w and (x,y) not in visited:
                            visited.append((x, y))  # labeling them as visited.
                            return DFS(visited, moves, x, y, z + 1 )  # recursively calling DFS
            else:
                continue
        s.pop()#popping out from stack
    return z
def max_reg(m):
    lst = [0] * len(m)
    for i in range(len(m)):
        for j in range(len(m[i])):
            if m[i][j] == 1:
                x = (i, j)  # i=row j=column
                c = DFS([x], moves, x[0], x[1], 1)
                lst[i] = c
    lst.sort()
    return lst[-1]

print(max_reg(mat))

"""Task2"""

inputfile2=open("/content/drive/MyDrive/Lab-01/input2.txt", "r")
m=int(inputfile2.readline())
n=int(inputfile2.readline())
mat2=inputfile2.readlines()
lst=[]
for e in mat2:
  if e[-1] == '\n':
    s = e[:-1].split()
  else:
    s = e.split()
  lst.append(s)
count=0
def alien_tracker(lst):
    al=[]
    for i in range(len(lst)):
        for j in range(len(lst[i])):
            if lst[i][j]=='A':
                al.append((i,j))
    return al
def human_tracker(lst):
    a=[]
    for i in range(len(lst)):
        for j in range(len(lst[i])):
            if lst[i][j]=='H':
                a.append((i,j))
    return a
q=[]
def BFS(lst,visited,row, column):
    global q,count
    q.append((row,column))#enqueueing process
    moves = [(0, -1), (0, 1), (1, 0), (-1, 0)]
    while len(q)>0:
        v=q[0]
        x,y=v
        for i in range(len(moves)):
            x, y = row + moves[i][0], column + moves[i][1]
            # here x denotes the new row and y denote the new column
            if x >= 0 and x <= len(lst) - 1 and y >= 0 and y <= len(lst[0]) - 1:  # for the margin part
                if lst[x][y] == 'H':
                    for w in visited:  # for all the adjacent
                        if (x, y) != w and (x, y) not in visited:
                            visited.append((x, y))
        q = q[1:]
    h=human_tracker(lst)
    for i in h:
        if i not in q:
            count+=1
    a=len(h)
    b=len(visited)        
    return a,b       
lst1=[]
#b=alien_tracker(lst)
b=alien_tracker(lst)
for i in range(len(lst)):
    for j in range(len(lst[i])):
            if lst[i][j] == 'H':
                for k in b:
                    x = (i, j)
                    c,d = BFS(lst,[k], x[0], x[1])
                    lst1.append((c,d))
i,j=lst1[-1]
time=i-j

print('Time:',time,'minutes')
if count==0:
    print('no one survived')
else:
    print(count,'survived.')